"use client";

import { useState, useCallback } from "react";
import { trpc } from "@/lib/trpc";
import type { AllowedImageType } from "@/lib/constants";

export type UploadStatus =
  | "idle"
  | "getting-url"
  | "uploading"
  | "processing"
  | "complete"
  | "error";

export interface UploadState {
  status: UploadStatus;
  progress: number;
  error: string | null;
  screenshotId: string | null;
}

export interface UseUploadOptions {
  flowId: string;
  onSuccess?: (screenshotId: string) => void;
  onError?: (error: string) => void;
}

export function useUpload({ flowId, onSuccess, onError }: UseUploadOptions) {
  const [state, setState] = useState<UploadState>({
    status: "idle",
    progress: 0,
    error: null,
    screenshotId: null,
  });

  const getUploadUrl = trpc.screenshots.getUploadUrl.useMutation();
  const createScreenshot = trpc.screenshots.create.useMutation();

  const reset = useCallback(() => {
    setState({
      status: "idle",
      progress: 0,
      error: null,
      screenshotId: null,
    });
  }, []);

  const upload = useCallback(
    async (file: File) => {
      try {
        // Reset state
        setState({
          status: "getting-url",
          progress: 0,
          error: null,
          screenshotId: null,
        });

        // Get presigned URL
        const { uploadUrl, key, screenshotId: _screenshotId } = await getUploadUrl.mutateAsync({
          flowId,
          fileName: file.name,
          contentType: file.type as AllowedImageType,
          fileSize: file.size,
        });

        // screenshotId is generated by the server but the actual DB record
        // is created after the upload completes via createScreenshot
        void _screenshotId;

        setState((prev) => ({
          ...prev,
          status: "uploading",
          progress: 0,
        }));

        // Upload to S3 with progress tracking
        await new Promise<void>((resolve, reject) => {
          const xhr = new XMLHttpRequest();

          xhr.upload.addEventListener("progress", (event) => {
            if (event.lengthComputable) {
              const percentComplete = Math.round(
                (event.loaded / event.total) * 100
              );
              setState((prev) => ({
                ...prev,
                progress: percentComplete,
              }));
            }
          });

          xhr.addEventListener("load", () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve();
            } else {
              reject(new Error(`Upload failed with status ${xhr.status}`));
            }
          });

          xhr.addEventListener("error", () => {
            reject(new Error("Upload failed"));
          });

          xhr.addEventListener("abort", () => {
            reject(new Error("Upload cancelled"));
          });

          xhr.open("PUT", uploadUrl);
          xhr.setRequestHeader("Content-Type", file.type);
          xhr.send(file);
        });

        setState((prev) => ({
          ...prev,
          status: "processing",
          progress: 100,
        }));

        // Create screenshot record
        const screenshot = await createScreenshot.mutateAsync({
          flowId,
          s3Key: key,
          title: file.name.replace(/\.[^.]+$/, ""),
          fileSize: file.size,
          mimeType: file.type,
        });

        setState({
          status: "complete",
          progress: 100,
          error: null,
          screenshotId: screenshot.id,
        });

        onSuccess?.(screenshot.id);
        return screenshot;
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : "Upload failed";
        setState({
          status: "error",
          progress: 0,
          error: errorMessage,
          screenshotId: null,
        });
        onError?.(errorMessage);
        throw err;
      }
    },
    [flowId, getUploadUrl, createScreenshot, onSuccess, onError]
  );

  return {
    upload,
    reset,
    ...state,
  };
}

// Hook for managing multiple uploads
export interface UploadItem {
  id: string;
  file: File;
  state: UploadState;
}

export function useMultiUpload({ flowId }: { flowId: string }) {
  const [uploads, setUploads] = useState<UploadItem[]>([]);
  const [isUploading, setIsUploading] = useState(false);

  const getUploadUrl = trpc.screenshots.getUploadUrl.useMutation();
  const createScreenshot = trpc.screenshots.create.useMutation();
  const utils = trpc.useUtils();

  const addFiles = useCallback((files: File[]) => {
    const newUploads: UploadItem[] = files.map((file) => ({
      id: crypto.randomUUID(),
      file,
      state: {
        status: "idle" as const,
        progress: 0,
        error: null,
        screenshotId: null,
      },
    }));
    setUploads((prev) => [...prev, ...newUploads]);
    return newUploads.map((u) => u.id);
  }, []);

  const removeUpload = useCallback((id: string) => {
    setUploads((prev) => prev.filter((u) => u.id !== id));
  }, []);

  const clearCompleted = useCallback(() => {
    setUploads((prev) =>
      prev.filter((u) => u.state.status !== "complete" && u.state.status !== "error")
    );
  }, []);

  const clearAll = useCallback(() => {
    setUploads([]);
  }, []);

  const updateUploadState = useCallback(
    (id: string, state: Partial<UploadState>) => {
      setUploads((prev) =>
        prev.map((u) =>
          u.id === id ? { ...u, state: { ...u.state, ...state } } : u
        )
      );
    },
    []
  );

  const uploadFile = useCallback(
    async (uploadItem: UploadItem) => {
      const { id, file } = uploadItem;

      try {
        updateUploadState(id, { status: "getting-url" });

        const { uploadUrl, key } = await getUploadUrl.mutateAsync({
          flowId,
          fileName: file.name,
          contentType: file.type as AllowedImageType,
          fileSize: file.size,
        });

        updateUploadState(id, { status: "uploading", progress: 0 });

        await new Promise<void>((resolve, reject) => {
          const xhr = new XMLHttpRequest();

          xhr.upload.addEventListener("progress", (event) => {
            if (event.lengthComputable) {
              const percentComplete = Math.round(
                (event.loaded / event.total) * 100
              );
              updateUploadState(id, { progress: percentComplete });
            }
          });

          xhr.addEventListener("load", () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve();
            } else {
              reject(new Error(`Upload failed with status ${xhr.status}`));
            }
          });

          xhr.addEventListener("error", () => reject(new Error("Upload failed")));
          xhr.addEventListener("abort", () => reject(new Error("Upload cancelled")));

          xhr.open("PUT", uploadUrl);
          xhr.setRequestHeader("Content-Type", file.type);
          xhr.send(file);
        });

        updateUploadState(id, { status: "processing", progress: 100 });

        const screenshot = await createScreenshot.mutateAsync({
          flowId,
          s3Key: key,
          title: file.name.replace(/\.[^.]+$/, ""),
          fileSize: file.size,
          mimeType: file.type,
        });

        updateUploadState(id, {
          status: "complete",
          progress: 100,
          screenshotId: screenshot.id,
        });

        return screenshot;
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : "Upload failed";
        updateUploadState(id, {
          status: "error",
          error: errorMessage,
        });
        throw err;
      }
    },
    [flowId, getUploadUrl, createScreenshot, updateUploadState]
  );

  const startUploads = useCallback(async () => {
    const pendingUploads = uploads.filter((u) => u.state.status === "idle");
    if (pendingUploads.length === 0) return;

    setIsUploading(true);

    // Upload files sequentially to avoid overwhelming the server
    for (const upload of pendingUploads) {
      try {
        await uploadFile(upload);
      } catch {
        // Error already handled in uploadFile
      }
    }

    setIsUploading(false);

    // Invalidate screenshots query to refresh the list
    utils.screenshots.getByFlow.invalidate({ flowId });
  }, [uploads, uploadFile, flowId, utils.screenshots.getByFlow]);

  const completedCount = uploads.filter((u) => u.state.status === "complete").length;
  const errorCount = uploads.filter((u) => u.state.status === "error").length;
  const pendingCount = uploads.filter(
    (u) => u.state.status === "idle" || u.state.status === "getting-url"
  ).length;

  return {
    uploads,
    isUploading,
    addFiles,
    removeUpload,
    clearCompleted,
    clearAll,
    startUploads,
    completedCount,
    errorCount,
    pendingCount,
  };
}
